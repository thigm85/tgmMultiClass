#' Check match of the resample indexes and prediction tags
#' 
#' @return In case there is a mismatch it will give you a warning if
#' \code{ignore_tag = TRUE} or trigger an \code{stop} in case 
#' \code{ignore_tag = FALSE}.
checkTags <- function(resample_tag, prediction_tag, ignore_tag){
  if (resample_tag != prediction_tag){
    if (ignore_tag){
      warning("Careful: There is a mismatch between prediction and resample tags.")
    } else {
      stop("There is a mismatch between prediction and resample tags.")
    }
  } 
}

#' Compute the Log Score of predictions
#' 
#' Compute the log score from multi-class probability predictions.
#' 
#' @details Given a set of \code{prediction} and \code{target} values it will
#'   compute the log score function for each prediction point.
#'   
#' @param prediction Should be a matrix where the number of columns is equal to
#'   the number of classes in the problem and each column contains the
#'   probability of a specific class being true, each row should sum to 1.
#' @param target Should be a matrix with same dimension as \code{prediction} 
#'   where each cell of the matrix count the number of successes of that 
#'   particular class within that observational unit. Each cell of the matrix 
#'   should be an integer greater or equal to zero.
#'   
#' @return Numeric vector with length equal to the number of rows of
#' \code{prediction} and \code{target} containing the log scores for each
#' prediction point.
#' 
#' @export       
computeLogScore <- function(prediction, target){
  as.numeric(rowSums(log(prediction) * target))
}

#' Compute prediction log scores for a \code{multiClass} object.
#' 
#' @details Given a \code{datasetResample} object and a compatible 
#' \code{multiClass} prediction object it compute log scores of the
#' predictions for each replication.
#' 
#' @inheritParams evaluateProbClass
#'  
#' @return A matrix where each column represents the prediction log scores
#' for a given replication. The number of rows is equal to the number
#' of prediction points.
computeLogScoreMultiClass <- function(resample_indexes, pred_obj){
  
  number_replicates <- mcGet(resample_indexes, "number_replicates")
  scores_all <- NULL
  
  for (i in 1:number_replicates){
    
    predictions_i <- mcGet(pred_obj, "prob", i)
    target_i <- mcGet(resample_indexes, "test_target", i)
    scores_all <- cbind(scores_all, computeLogScore(prediction = predictions_i, target = target_i))
    
  }
  
  return(scores_all)
  
} 

#' Evaluate predicted class probabilities for a given score function.
#' 
#' @details Given a \code{datasetResample} object and a compatible 
#' \code{multiClass} prediction object it computes prediction scores
#' of some \code{type} for each replication. 
#' 
#' @param resample_indexes A \code{datasetResample} object, usually
#'  generated by the \code{generateTestIndexes} function.
#' @param pred_obj A \code{multiClass} object, usually generated
#'  from the \code{datasetResample} object with
#'  some predictive model with an interface function to 
#'  the \code{tgmMultiClass} package.
#' @param type Which type of score function should be used. Currently,
#'  on \code{log_score} is available.
#' @param ignore_tag Before computing scores, we check to see if 
#'  \code{pred_obj} was indeed generated from the \code{resample_indexes}.
#'  In case of a mismatch an error is issued, unless \code{ignore_tag = FALSE},
#'  in which case just a warning is issued.
#' 
#' @return A matrix where each column represents the scores
#' for a given replication. The number of rows is equal to the number
#' of prediction points.
evaluateProbClass <- function(resample_indexes, pred_obj, type, ignore_tag = FALSE){
  
  resample_tag <- mcGet(resample_indexes, "tag")
  prediction_tag <- mcGet(pred_obj, "tag")
  
  checkTags(resample_tag = resample_tag, 
            prediction_tag = prediction_tag, 
            ignore_tag = ignore_tag)
    
  if (type == "log_score"){
    result <- computeLogScoreMultiClass(resample_indexes = resample_indexes, pred_obj = pred_obj)
  } else {
    stop("Invalid type.\n")
  }
      
  return(result)
  
}
