#' probability prediction with 'glm'
#' 
#' \code{predict_r_glm_prob} apply \code{glm} function to different training and test sets to predict class probability.
#' 
#' \code{predict_r_glm_prob} will then train with the training and validation
#' parts of the data using \code{glm} and output the predicted probabilities
#' on the test sets.
#' 
#' @param resample_indexes An object that contains information about resampled 
#'  instances of \code{data}, usually generated by \code{\link{generateTestIndexes}}.
#' @param verbose TRUE (default) for printing what is the current replication running. 
#' @param ... Arguments to be used in the \code{glm} function.
#' 
#' @return It returns an S3 object of class c("multiClass_glm", "multiClass").
#' This object contains the predicted probabilities for each test set. See 
#' the examples to get more info about how to extract the desired info from 
#' this object.     
#' 
#' @seealso \code{\link{generateTestIndexes}}
#' 
# @examples
# data(soccer_game)
# indexes <- generateTestIndexes(dataset = soccer_game, 
#                                target_names = c("home.win", "home.draw", "home.lose"), 
#                                type = "3way", 
#                                options = list(prop_v = 0.2, 
#                                               prop_test = 0.2,
#                                               number_replicates = 4))
# pred_obj <- predict_r_vgam(resample_indexes = indexes,
#                            formula = cbind(home.win, home.draw, home.lose) ~ 1 + fair.odd.home + fair.odd.draw + fair.odd.away, 
#                            family = "multinomial")   
# 
# all_predictions <- mcGet(pred_obj, "prob")
# second_replication_only <- mcGet(pred_obj, "prob", 2)
#' 
#' @export
predict_r_glm_prob <- function(resample_indexes, verbose = TRUE, ...){
  
  data <- mcGet(resample_indexes, "dataset")
  
  tag <- mcGet(resample_indexes, "tag")
  
  number_replications <- mcGet(resample_indexes, "number_replicates")
  keep_probs <- list()
  
  keep_probs <- foreach(index = 1:number_replications, .inorder=TRUE) %dopar% {
    trainAndPredict_glm_prob(index = index, resample_indexes = resample_indexes, 
                             verbose = verbose, number_replications = number_replications, ...)
  }
  
#   for (i in 1:number_replications){
#         
#     if (verbose){
#       print(paste("Iteration: ", i, "/", number_replications, sep = ""))
#     }
# 
#     training_data <- data[c(mcGet(resample_indexes, "training", i), mcGet(resample_indexes, "validation", i)), ]
# 
#     fit <- do.call(what = "glm", args = list(data = training_data, ...))
#     
#     probs <- predict(fit, newdata = data[mcGet(resample_indexes, "test", i), ], type = "response")  
#     keep_probs[[i]] <- c(as.numeric(probs), as.numeric(1 - probs))
#     
#   }
    
  result <- multiClass(resample_indexes = resample_indexes,
                       prob = keep_probs)
  
  return(result)
  
}

trainAndPredict_glm_prob <- function(index, resample_indexes, verbose, number_replications, ...){
 
  if (verbose){
    print(paste("Iteration: ", index, "/", number_replications, sep = ""))
  }
  
  training_data <- data[c(mcGet(resample_indexes, "training", index), mcGet(resample_indexes, "validation", index)), ]
  
  fit <- do.call(what = "glm", args = list(data = training_data, ...))
  
  test_data <- data[mcGet(resample_indexes, "test", index), ]
  
  categorical_variables <- names(fit$xlevels)
  for (i in categorical_variables){
    fit$xlevels[[i]] <- union(fit$xlevels[[i]], levels(test_data[[i]]))  
  }
  
  probs <- predict(fit, newdata = test_data, type = "response")  
  result <- c(as.numeric(probs), as.numeric(1 - probs))
  return(result)
  
}